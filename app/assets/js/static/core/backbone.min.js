(function() {
    var root = this, previousBackbone = root.Backbone, slice = Array.prototype.slice, splice = Array.prototype.splice, Backbone;
    typeof exports != "undefined" ? Backbone = exports : Backbone = root.Backbone = {}, Backbone.VERSION = "0.9.1";
    var _ = root._;
    !_ && typeof require != "undefined" && (_ = require("underscore"));
    var $ = root.jQuery || root.Zepto || root.ender;
    Backbone.setDomLibrary = function(lib) {
        $ = lib;
    }, Backbone.noConflict = function() {
        return root.Backbone = previousBackbone, this;
    }, Backbone.emulateHTTP = !1, Backbone.emulateJSON = !1, Backbone.Events = {
        on: function(events, callback, context) {
            var ev;
            events = events.split(/\s+/);
            var calls = this._callbacks || (this._callbacks = {});
            while (ev = events.shift()) {
                var list = calls[ev] || (calls[ev] = {}), tail = list.tail || (list.tail = list.next = {});
                tail.callback = callback, tail.context = context, list.tail = tail.next = {};
            }
            return this;
        },
        off: function(events, callback, context) {
            var ev, calls, node;
            if (!events) delete this._callbacks; else if (calls = this._callbacks) {
                events = events.split(/\s+/);
                while (ev = events.shift()) {
                    node = calls[ev], delete calls[ev];
                    if (!callback || !node) continue;
                    while ((node = node.next) && node.next) {
                        if (node.callback === callback && (!context || node.context === context)) continue;
                        this.on(ev, node.callback, node.context);
                    }
                }
            }
            return this;
        },
        trigger: function(events) {
            var event, node, calls, tail, args, all, rest;
            if (!(calls = this._callbacks)) return this;
            all = calls.all, (events = events.split(/\s+/)).push(null);
            while (event = events.shift()) {
                all && events.push({
                    next: all.next,
                    tail: all.tail,
                    event: event
                });
                if (!(node = calls[event])) continue;
                events.push({
                    next: node.next,
                    tail: node.tail
                });
            }
            rest = slice.call(arguments, 1);
            while (node = events.pop()) {
                tail = node.tail, args = node.event ? [ node.event ].concat(rest) : rest;
                while ((node = node.next) !== tail) node.callback.apply(node.context || this, args);
            }
            return this;
        }
    }, Backbone.Events.bind = Backbone.Events.on, Backbone.Events.unbind = Backbone.Events.off, Backbone.Model = function(attributes, options) {
        var defaults;
        attributes || (attributes = {}), options && options.parse && (attributes = this.parse(attributes));
        if (defaults = getValue(this, "defaults")) attributes = _.extend({}, defaults, attributes);
        options && options.collection && (this.collection = options.collection), this.attributes = {}, this._escapedAttributes = {}, this.cid = _.uniqueId("c");
        if (!this.set(attributes, {
            silent: !0
        })) throw new Error("Can't create an invalid model");
        delete this._changed, this._previousAttributes = _.clone(this.attributes), this.initialize.apply(this, arguments);
    }, _.extend(Backbone.Model.prototype, Backbone.Events, {
        idAttribute: "id",
        initialize: function() {},
        toJSON: function() {
            return _.clone(this.attributes);
        },
        get: function(attr) {
            return this.attributes[attr];
        },
        escape: function(attr) {
            var html;
            if (html = this._escapedAttributes[attr]) return html;
            var val = this.attributes[attr];
            return this._escapedAttributes[attr] = _.escape(val == null ? "" : "" + val);
        },
        has: function(attr) {
            return this.attributes[attr] != null;
        },
        set: function(key, value, options) {
            var attrs, attr, val;
            _.isObject(key) || key == null ? (attrs = key, options = value) : (attrs = {}, attrs[key] = value), options || (options = {});
            if (!attrs) return this;
            attrs instanceof Backbone.Model && (attrs = attrs.attributes);
            if (options.unset) for (attr in attrs) attrs[attr] = void 0;
            if (!this._validate(attrs, options)) return !1;
            this.idAttribute in attrs && (this.id = attrs[this.idAttribute]);
            var now = this.attributes, escaped = this._escapedAttributes, prev = this._previousAttributes || {}, alreadySetting = this._setting;
            this._changed || (this._changed = {}), this._setting = !0;
            for (attr in attrs) {
                val = attrs[attr], _.isEqual(now[attr], val) || delete escaped[attr], options.unset ? delete now[attr] : now[attr] = val, this._changing && !_.isEqual(this._changed[attr], val) && (this.trigger("change:" + attr, this, val, options), this._moreChanges = !0), delete this._changed[attr];
                if (!_.isEqual(prev[attr], val) || _.has(now, attr) != _.has(prev, attr)) this._changed[attr] = val;
            }
            return alreadySetting || (!options.silent && this.hasChanged() && this.change(options), this._setting = !1), this;
        },
        unset: function(attr, options) {
            return (options || (options = {})).unset = !0, this.set(attr, null, options);
        },
        clear: function(options) {
            return (options || (options = {})).unset = !0, this.set(_.clone(this.attributes), options);
        },
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            var model = this, success = options.success;
            return options.success = function(resp, status, xhr) {
                if (!model.set(model.parse(resp, xhr), options)) return !1;
                success && success(model, resp);
            }, options.error = Backbone.wrapError(options.error, model, options), (this.sync || Backbone.sync).call(this, "read", this, options);
        },
        save: function(key, value, options) {
            var attrs, current;
            _.isObject(key) || key == null ? (attrs = key, options = value) : (attrs = {}, attrs[key] = value), options = options ? _.clone(options) : {}, options.wait && (current = _.clone(this.attributes));
            var silentOptions = _.extend({}, options, {
                silent: !0
            });
            if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) return !1;
            var model = this, success = options.success;
            options.success = function(resp, status, xhr) {
                var serverAttrs = model.parse(resp, xhr);
                options.wait && (serverAttrs = _.extend(attrs || {}, serverAttrs));
                if (!model.set(serverAttrs, options)) return !1;
                success ? success(model, resp) : model.trigger("sync", model, resp, options);
            }, options.error = Backbone.wrapError(options.error, model, options);
            var method = this.isNew() ? "create" : "update", xhr = (this.sync || Backbone.sync).call(this, method, this, options);
            return options.wait && this.set(current, silentOptions), xhr;
        },
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this, success = options.success, triggerDestroy = function() {
                model.trigger("destroy", model, model.collection, options);
            };
            if (this.isNew()) return triggerDestroy();
            options.success = function(resp) {
                options.wait && triggerDestroy(), success ? success(model, resp) : model.trigger("sync", model, resp, options);
            }, options.error = Backbone.wrapError(options.error, model, options);
            var xhr = (this.sync || Backbone.sync).call(this, "delete", this, options);
            return options.wait || triggerDestroy(), xhr;
        },
        url: function() {
            var base = getValue(this.collection, "url") || getValue(this, "urlRoot") || urlError();
            return this.isNew() ? base : base + (base.charAt(base.length - 1) == "/" ? "" : "/") + encodeURIComponent(this.id);
        },
        parse: function(resp, xhr) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return this.id == null;
        },
        change: function(options) {
            if (this._changing || !this.hasChanged()) return this;
            this._changing = !0, this._moreChanges = !0;
            for (var attr in this._changed) this.trigger("change:" + attr, this, this._changed[attr], options);
            while (this._moreChanges) this._moreChanges = !1, this.trigger("change", this, options);
            return this._previousAttributes = _.clone(this.attributes), delete this._changed, this._changing = !1, this;
        },
        hasChanged: function(attr) {
            return arguments.length ? this._changed && _.has(this._changed, attr) : !_.isEmpty(this._changed);
        },
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this._changed) : !1;
            var val, changed = !1, old = this._previousAttributes;
            for (var attr in diff) {
                if (_.isEqual(old[attr], val = diff[attr])) continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        },
        previous: function(attr) {
            return !arguments.length || !this._previousAttributes ? null : this._previousAttributes[attr];
        },
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },
        isValid: function() {
            return !this.validate(this.attributes);
        },
        _validate: function(attrs, options) {
            if (options.silent || !this.validate) return !0;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validate(attrs, options);
            return error ? (options && options.error ? options.error(this, error, options) : this.trigger("error", this, error, options), !1) : !0;
        }
    }), Backbone.Collection = function(models, options) {
        options || (options = {}), options.comparator && (this.comparator = options.comparator), this._reset(), this.initialize.apply(this, arguments), models && this.reset(models, {
            silent: !0,
            parse: options.parse
        });
    }, _.extend(Backbone.Collection.prototype, Backbone.Events, {
        model: Backbone.Model,
        initialize: function() {},
        toJSON: function() {
            return this.map(function(model) {
                return model.toJSON();
            });
        },
        add: function(models, options) {
            var i, index, length, model, cid, id, cids = {}, ids = {};
            options || (options = {}), models = _.isArray(models) ? models.slice() : [ models ];
            for (i = 0, length = models.length; i < length; i++) {
                if (!(model = models[i] = this._prepareModel(models[i], options))) throw new Error("Can't add an invalid model to a collection");
                if (cids[cid = model.cid] || this._byCid[cid] || (id = model.id) != null && (ids[id] || this._byId[id])) throw new Error("Can't add the same model to a collection twice");
                cids[cid] = ids[id] = model;
            }
            for (i = 0; i < length; i++) (model = models[i]).on("all", this._onModelEvent, this), this._byCid[model.cid] = model, model.id != null && (this._byId[model.id] = model);
            this.length += length, index = options.at != null ? options.at : this.models.length, splice.apply(this.models, [ index, 0 ].concat(models)), this.comparator && this.sort({
                silent: !0
            });
            if (options.silent) return this;
            for (i = 0, length = this.models.length; i < length; i++) {
                if (!cids[(model = this.models[i]).cid]) continue;
                options.index = i, model.trigger("add", model, this, options);
            }
            return this;
        },
        remove: function(models, options) {
            var i, l, index, model;
            options || (options = {}), models = _.isArray(models) ? models.slice() : [ models ];
            for (i = 0, l = models.length; i < l; i++) {
                model = this.getByCid(models[i]) || this.get(models[i]);
                if (!model) continue;
                delete this._byId[model.id], delete this._byCid[model.cid], index = this.indexOf(model), this.models.splice(index, 1), this.length--, options.silent || (options.index = index, model.trigger("remove", model, this, options)), this._removeReference(model);
            }
            return this;
        },
        get: function(id) {
            return id == null ? null : this._byId[id.id != null ? id.id : id];
        },
        getByCid: function(cid) {
            return cid && this._byCid[cid.cid || cid];
        },
        at: function(index) {
            return this.models[index];
        },
        sort: function(options) {
            options || (options = {});
            if (!this.comparator) throw new Error("Cannot sort a set without a comparator");
            var boundComparator = _.bind(this.comparator, this);
            return this.comparator.length == 1 ? this.models = this.sortBy(boundComparator) : this.models.sort(boundComparator), options.silent || this.trigger("reset", this, options), this;
        },
        pluck: function(attr) {
            return _.map(this.models, function(model) {
                return model.get(attr);
            });
        },
        reset: function(models, options) {
            models || (models = []), options || (options = {});
            for (var i = 0, l = this.models.length; i < l; i++) this._removeReference(this.models[i]);
            return this._reset(), this.add(models, {
                silent: !0,
                parse: options.parse
            }), options.silent || this.trigger("reset", this, options), this;
        },
        fetch: function(options) {
            options = options ? _.clone(options) : {}, options.parse === undefined && (options.parse = !0);
            var collection = this, success = options.success;
            return options.success = function(resp, status, xhr) {
                collection[options.add ? "add" : "reset"](collection.parse(resp, xhr), options), success && success(collection, resp);
            }, options.error = Backbone.wrapError(options.error, collection, options), (this.sync || Backbone.sync).call(this, "read", this, options);
        },
        create: function(model, options) {
            var coll = this;
            options = options ? _.clone(options) : {}, model = this._prepareModel(model, options);
            if (!model) return !1;
            options.wait || coll.add(model, options);
            var success = options.success;
            return options.success = function(nextModel, resp, xhr) {
                options.wait && coll.add(nextModel, options), success ? success(nextModel, resp) : nextModel.trigger("sync", model, resp, options);
            }, model.save(null, options), model;
        },
        parse: function(resp, xhr) {
            return resp;
        },
        chain: function() {
            return _(this.models).chain();
        },
        _reset: function(options) {
            this.length = 0, this.models = [], this._byId = {}, this._byCid = {};
        },
        _prepareModel: function(model, options) {
            if (model instanceof Backbone.Model) model.collection || (model.collection = this); else {
                var attrs = model;
                options.collection = this, model = new this.model(attrs, options), model._validate(model.attributes, options) || (model = !1);
            }
            return model;
        },
        _removeReference: function(model) {
            this == model.collection && delete model.collection, model.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(ev, model, collection, options) {
            if ((ev == "add" || ev == "remove") && collection != this) return;
            ev == "destroy" && this.remove(model, options), model && ev === "change:" + model.idAttribute && (delete this._byId[model.previous(model.idAttribute)], this._byId[model.id] = model), this.trigger.apply(this, arguments);
        }
    });
    var methods = [ "forEach", "each", "map", "reduce", "reduceRight", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "sortBy", "sortedIndex", "toArray", "size", "first", "initial", "rest", "last", "without", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "groupBy" ];
    _.each(methods, function(method) {
        Backbone.Collection.prototype[method] = function() {
            return _[method].apply(_, [ this.models ].concat(_.toArray(arguments)));
        };
    }), Backbone.Router = function(options) {
        options || (options = {}), options.routes && (this.routes = options.routes), this._bindRoutes(), this.initialize.apply(this, arguments);
    };
    var namedParam = /:\w+/g, splatParam = /\*\w+/g, escapeRegExp = /[-[\]{}()+?.,\\^$|#\s]/g;
    _.extend(Backbone.Router.prototype, Backbone.Events, {
        initialize: function() {},
        route: function(route, name, callback) {
            return Backbone.history || (Backbone.history = new Backbone.History), _.isRegExp(route) || (route = this._routeToRegExp(route)), callback || (callback = this[name]), Backbone.history.route(route, _.bind(function(fragment) {
                var args = this._extractParameters(route, fragment);
                callback && callback.apply(this, args), this.trigger.apply(this, [ "route:" + name ].concat(args)), Backbone.history.trigger("route", this, name, args);
            }, this)), this;
        },
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
        },
        _bindRoutes: function() {
            if (!this.routes) return;
            var routes = [];
            for (var route in this.routes) routes.unshift([ route, this.routes[route] ]);
            for (var i = 0, l = routes.length; i < l; i++) this.route(routes[i][0], routes[i][1], this[routes[i][1]]);
        },
        _routeToRegExp: function(route) {
            return route = route.replace(escapeRegExp, "\\$&").replace(namedParam, "([^/]+)").replace(splatParam, "(.*?)"), new RegExp("^" + route + "$");
        },
        _extractParameters: function(route, fragment) {
            return route.exec(fragment).slice(1);
        }
    }), Backbone.History = function() {
        this.handlers = [], _.bindAll(this, "checkUrl");
    };
    var routeStripper = /^[#\/]/, isExplorer = /msie [\w.]+/, historyStarted = !1;
    _.extend(Backbone.History.prototype, Backbone.Events, {
        interval: 50,
        getFragment: function(fragment, forcePushState) {
            if (fragment == null) if (this._hasPushState || forcePushState) {
                fragment = window.location.pathname;
                var search = window.location.search;
                search && (fragment += search);
            } else fragment = window.location.hash;
            return fragment = decodeURIComponent(fragment), fragment.indexOf(this.options.root) || (fragment = fragment.substr(this.options.root.length)), fragment.replace(routeStripper, "");
        },
        start: function(options) {
            if (historyStarted) throw new Error("Backbone.history has already been started");
            this.options = _.extend({}, {
                root: "/"
            }, this.options, options), this._wantsHashChange = this.options.hashChange !== !1, this._wantsPushState = !!this.options.pushState, this._hasPushState = !!(this.options.pushState && window.history && window.history.pushState);
            var fragment = this.getFragment(), docMode = document.documentMode, oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
            oldIE && (this.iframe = $('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow, this.navigate(fragment)), this._hasPushState ? $(window).bind("popstate", this.checkUrl) : this._wantsHashChange && "onhashchange" in window && !oldIE ? $(window).bind("hashchange", this.checkUrl) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), this.fragment = fragment, historyStarted = !0;
            var loc = window.location, atRoot = loc.pathname == this.options.root;
            if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) return this.fragment = this.getFragment(null, !0), window.location.replace(this.options.root + "#" + this.fragment), !0;
            this._wantsPushState && this._hasPushState && atRoot && loc.hash && (this.fragment = loc.hash.replace(routeStripper, ""), window.history.replaceState({}, document.title, loc.protocol + "//" + loc.host + this.options.root + this.fragment));
            if (!this.options.silent) return this.loadUrl();
        },
        stop: function() {
            $(window).unbind("popstate", this.checkUrl).unbind("hashchange", this.checkUrl), clearInterval(this._checkUrlInterval), historyStarted = !1;
        },
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        checkUrl: function(e) {
            var current = this.getFragment();
            current == this.fragment && this.iframe && (current = this.getFragment(this.iframe.location.hash));
            if (current == this.fragment || current == decodeURIComponent(this.fragment)) return !1;
            this.iframe && this.navigate(current), this.loadUrl() || this.loadUrl(window.location.hash);
        },
        loadUrl: function(fragmentOverride) {
            var fragment = this.fragment = this.getFragment(fragmentOverride), matched = _.any(this.handlers, function(handler) {
                if (handler.route.test(fragment)) return handler.callback(fragment), !0;
            });
            return matched;
        },
        navigate: function(fragment, options) {
            if (!historyStarted) return !1;
            if (!options || options === !0) options = {
                trigger: options
            };
            var frag = (fragment || "").replace(routeStripper, "");
            if (this.fragment == frag || this.fragment == decodeURIComponent(frag)) return;
            this._hasPushState ? (frag.indexOf(this.options.root) != 0 && (frag = this.options.root + frag), this.fragment = frag, window.history[options.replace ? "replaceState" : "pushState"]({}, document.title, frag)) : this._wantsHashChange ? (this.fragment = frag, this._updateHash(window.location, frag, options.replace), this.iframe && frag != this.getFragment(this.iframe.location.hash) && (options.replace || this.iframe.document.open().close(), this._updateHash(this.iframe.location, frag, options.replace))) : window.location.assign(this.options.root + fragment), options.trigger && this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
            replace ? location.replace(location.toString().replace(/(javascript:|#).*$/, "") + "#" + fragment) : location.hash = fragment;
        }
    }), Backbone.View = function(options) {
        this.cid = _.uniqueId("view"), this._configure(options || {}), this._ensureElement(), this.initialize.apply(this, arguments), this.delegateEvents();
    };
    var eventSplitter = /^(\S+)\s*(.*)$/, viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName" ];
    _.extend(Backbone.View.prototype, Backbone.Events, {
        tagName: "div",
        $: function(selector) {
            return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            return this.$el.remove(), this;
        },
        make: function(tagName, attributes, content) {
            var el = document.createElement(tagName);
            return attributes && $(el).attr(attributes), content && $(el).html(content), el;
        },
        setElement: function(element, delegate) {
            return this.$el = $(element), this.el = this.$el[0], delegate !== !1 && this.delegateEvents(), this;
        },
        delegateEvents: function(events) {
            if (!events && !(events = getValue(this, "events"))) return;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                _.isFunction(method) || (method = this[events[key]]);
                if (!method) throw new Error('Event "' + events[key] + '" does not exist');
                var match = key.match(eventSplitter), eventName = match[1], selector = match[2];
                method = _.bind(method, this), eventName += ".delegateEvents" + this.cid, selector === "" ? this.$el.bind(eventName, method) : this.$el.delegate(selector, eventName, method);
            }
        },
        undelegateEvents: function() {
            this.$el.unbind(".delegateEvents" + this.cid);
        },
        _configure: function(options) {
            this.options && (options = _.extend({}, this.options, options));
            for (var i = 0, l = viewOptions.length; i < l; i++) {
                var attr = viewOptions[i];
                options[attr] && (this[attr] = options[attr]);
            }
            this.options = options;
        },
        _ensureElement: function() {
            if (!this.el) {
                var attrs = getValue(this, "attributes") || {};
                this.id && (attrs.id = this.id), this.className && (attrs["class"] = this.className), this.setElement(this.make(this.tagName, attrs), !1);
            } else this.setElement(this.el, !1);
        }
    });
    var extend = function(protoProps, classProps) {
        var child = inherits(this, protoProps, classProps);
        return child.extend = this.extend, child;
    };
    Backbone.Model.extend = Backbone.Collection.extend = Backbone.Router.extend = Backbone.View.extend = extend;
    var methodMap = {
        create: "POST",
        update: "PUT",
        "delete": "DELETE",
        read: "GET"
    };
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method], params = {
            type: type,
            dataType: "json"
        };
        return options.url || (params.url = getValue(model, "url") || urlError()), !options.data && model && (method == "create" || method == "update") && (params.contentType = "application/json", params.data = JSON.stringify(model.toJSON())), Backbone.emulateJSON && (params.contentType = "application/x-www-form-urlencoded", params.data = params.data ? {
            model: params.data
        } : {}), Backbone.emulateHTTP && (type === "PUT" || type === "DELETE") && (Backbone.emulateJSON && (params.data._method = type), params.type = "POST", params.beforeSend = function(xhr) {
            xhr.setRequestHeader("X-HTTP-Method-Override", type);
        }), params.type !== "GET" && !Backbone.emulateJSON && (params.processData = !1), $.ajax(_.extend(params, options));
    }, Backbone.wrapError = function(onError, originalModel, options) {
        return function(model, resp) {
            resp = model === originalModel ? resp : model, onError ? onError(originalModel, resp, options) : originalModel.trigger("error", originalModel, resp, options);
        };
    };
    var ctor = function() {}, inherits = function(parent, protoProps, staticProps) {
        var child;
        return protoProps && protoProps.hasOwnProperty("constructor") ? child = protoProps.constructor : child = function() {
            parent.apply(this, arguments);
        }, _.extend(child, parent), ctor.prototype = parent.prototype, child.prototype = new ctor, protoProps && _.extend(child.prototype, protoProps), staticProps && _.extend(child, staticProps), child.prototype.constructor = child, child.__super__ = parent.prototype, child;
    }, getValue = function(object, prop) {
        return !object || !object[prop] ? null : _.isFunction(object[prop]) ? object[prop]() : object[prop];
    }, urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };
}).call(this);